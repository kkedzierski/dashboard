{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation for CGRD dashboard Welcome to the documentation page for the cgrd-dashboard portal! Used solutions: Docker: The applications are run in Docker containers, allowing easy deployment on any operating system. Client side: - vanilla JavaScript, HTML, CSS - Atomic design - Web components The Atomic Design approach has been applied, enabling modular development of web applications. The client-side application communicates with the API server using a JWT token returned by the server. It was built in plain JavaScript, without frameworks, which allows for a fast application, designed as a React-like framework imitation. Server side: - PHP 8.0, PHPUnit The server was also developed in plain PHP, without frameworks, allowing for a fast application. Developed using the DDD (Domain-Driven Design) approach Implemented migrations Unit tests have been implemented Implemented API Implemented JWT authorization Implemented error handling Implemented logging Technical guide Installation Running Tests Api documentation Code documentation This documentation Table of contents Future improvements Authors","title":"Home"},{"location":"#documentation-for-cgrd-dashboard","text":"Welcome to the documentation page for the cgrd-dashboard portal!","title":"Documentation for CGRD dashboard"},{"location":"#used-solutions","text":"","title":"Used solutions:"},{"location":"#docker","text":"The applications are run in Docker containers, allowing easy deployment on any operating system.","title":"Docker:"},{"location":"#client-side","text":"","title":"Client side:"},{"location":"#-vanilla-javascript-html-css","text":"","title":"- vanilla JavaScript, HTML, CSS"},{"location":"#-atomic-design","text":"","title":"- Atomic design"},{"location":"#-web-components","text":"The Atomic Design approach has been applied, enabling modular development of web applications. The client-side application communicates with the API server using a JWT token returned by the server. It was built in plain JavaScript, without frameworks, which allows for a fast application, designed as a React-like framework imitation.","title":"- Web components"},{"location":"#server-side","text":"","title":"Server side:"},{"location":"#-php-80-phpunit","text":"The server was also developed in plain PHP, without frameworks, allowing for a fast application. Developed using the DDD (Domain-Driven Design) approach Implemented migrations Unit tests have been implemented Implemented API Implemented JWT authorization Implemented error handling Implemented logging","title":"- PHP 8.0, PHPUnit"},{"location":"#technical-guide","text":"Installation Running Tests Api documentation Code documentation This documentation","title":"Technical guide"},{"location":"#table-of-contents","text":"Future improvements Authors","title":"Table of contents"},{"location":"authors/","text":"Kamil K\u0119dzierski","title":"Authors"},{"location":"futureImprovement/","text":"Future improvement CI/CD pipeline Functional testing in behat Testing services in Jest","title":"Future improvements"},{"location":"futureImprovement/#future-improvement","text":"CI/CD pipeline Functional testing in behat Testing services in Jest","title":"Future improvement"},{"location":"technicalGuide/api/","text":"API documentation How to Add a New Route? To add a new route, go to the server folder and edit the App\\Kernel\\Router\\RegisterRouteManager file. In the registerRoutes method, add a new entry in the following format: $this->router->registerRoute('method', 'path', 'controller class' 'controller method'); Example: $this->router->registerRoute('POST', '/login', LoginController::class, 'login'); What Routes Are Currently Available? POST api/v1/login params: email, password Function: Logs in the user and returns a JWT token or an error. GET api/v1/auth Checks if the user is logged in. GET api/v1/news-posts Returns all news posts. POST api/v1/news-posts params: title, content Function: Adds a new news post. PATCH api/v1/news-posts params: id, title, content Function: Updates a news post. DELETE api/v1/news-posts params: id Function: Deletes a news post.","title":"Api documentation"},{"location":"technicalGuide/api/#api-documentation","text":"How to Add a New Route? To add a new route, go to the server folder and edit the App\\Kernel\\Router\\RegisterRouteManager file. In the registerRoutes method, add a new entry in the following format: $this->router->registerRoute('method', 'path', 'controller class' 'controller method'); Example: $this->router->registerRoute('POST', '/login', LoginController::class, 'login'); What Routes Are Currently Available? POST api/v1/login params: email, password Function: Logs in the user and returns a JWT token or an error. GET api/v1/auth Checks if the user is logged in. GET api/v1/news-posts Returns all news posts. POST api/v1/news-posts params: title, content Function: Adds a new news post. PATCH api/v1/news-posts params: id, title, content Function: Updates a news post. DELETE api/v1/news-posts params: id Function: Deletes a news post.","title":"API documentation"},{"location":"technicalGuide/clientCode/","text":"Code documentation A main.js file has been created in the codebase. This file checks if the user has a token. If so, it redirects them to the dashboard; if not, it redirects them to the login page. Two folders have been created for components: components - contains all components used in the application core - contains components that are used in multiple places within the application Core components were created to simplify and improve the readability of the code when creating new components. How to Add a New Component? To create, for example, an atom: Approach for Simple Components Create a new folder in src/components/atoms. In this folder, create a file xxx.js, where the component will be defined. Add the import for the new component in main.js. In the xxx.js file, create a class that inherits from CoreHtmlElement. Define the component name using the propertyName parameter. Import the core element you want to inherit, such as CoreImg. Assign it a class or any other attributes as needed. Pass the element to super. Define customElement. Done. Example: import { CoreImg } from '../../../core/atoms/Img/CoreImg.js'; import CoreHtmlElement from '../../../core/molecules/CoreHtmlElement.js'; export class Logo extends CoreHtmlElement { static propertyName = 'app-logo'; constructor() { const logo = CoreImg({ class: 'logo', src: 'assets/images/logo.svg', alt: 'Logo CGRD', }); super({ element: logo }); } } customElements.define(Logo.propertyName, Logo); Approach for Complex Components Create a new folder in src/components/atoms. In this folder, create a file xxx.js, where the component will be defined. Add the import for the new component in main.js. In the xxx.js file, create a class that inherits from HtmlElement. Define the component name using the propertyName parameter. Import the core element you want to inherit, such as CoreImg. Assign it a class or any other attributes as needed. Create a shadowRoot with const shadowRoot = this.attachShadow({ mode: 'open' }); Add your element to the shadowRoot using shadowRoot.appendChild(input); Define customElement. Done. Example: import { CoreInput } from '../../../core/atoms/Input/CoreInput.js'; import { CoreStyle } from '../../../core/atoms/Style/CoreStyle.js'; export class Input extends HTMLElement { static propertyName = 'app-input'; constructor(placeholder = '', name = '', type = 'text') { super(); this.placeholder = placeholder; this.name = name; this.type = type; if (this.getAttribute('placeholder')) { const placeholder = this.getAttribute('placeholder'); this.placeholder = placeholder.charAt(0).toUpperCase() + placeholder.slice(1); } if (this.getAttribute('name')) { this.name = this.getAttribute('name'); } if (this.getAttribute('type')) { this.type = this.getAttribute('type'); } const shadowRoot = this.attachShadow({ mode: 'open' }); this.createComponent(shadowRoot); } createComponent(shadowRoot) { const input = CoreInput({ placeholder: this.placeholder, name: this.name, type: this.type, class: 'input', }); const style = CoreStyle({ textContent: ` .input { color: black; padding: 0.8rem; border: 1px solid #ccc; border-radius: 5px; width: 680px; cursor: pointer; background-color: rgba(248, 249, 250, 0.8); } .input:focus { outline: none; background-color: #fff; } @media (max-width: 768px) { .input { width: 300px; } } `, }); shadowRoot.appendChild(style); shadowRoot.appendChild(input); } } customElements.define(Input.propertyName, Input);","title":"Client code documentation"},{"location":"technicalGuide/clientCode/#code-documentation","text":"A main.js file has been created in the codebase. This file checks if the user has a token. If so, it redirects them to the dashboard; if not, it redirects them to the login page. Two folders have been created for components: components - contains all components used in the application core - contains components that are used in multiple places within the application Core components were created to simplify and improve the readability of the code when creating new components. How to Add a New Component? To create, for example, an atom: Approach for Simple Components Create a new folder in src/components/atoms. In this folder, create a file xxx.js, where the component will be defined. Add the import for the new component in main.js. In the xxx.js file, create a class that inherits from CoreHtmlElement. Define the component name using the propertyName parameter. Import the core element you want to inherit, such as CoreImg. Assign it a class or any other attributes as needed. Pass the element to super. Define customElement. Done. Example: import { CoreImg } from '../../../core/atoms/Img/CoreImg.js'; import CoreHtmlElement from '../../../core/molecules/CoreHtmlElement.js'; export class Logo extends CoreHtmlElement { static propertyName = 'app-logo'; constructor() { const logo = CoreImg({ class: 'logo', src: 'assets/images/logo.svg', alt: 'Logo CGRD', }); super({ element: logo }); } } customElements.define(Logo.propertyName, Logo); Approach for Complex Components Create a new folder in src/components/atoms. In this folder, create a file xxx.js, where the component will be defined. Add the import for the new component in main.js. In the xxx.js file, create a class that inherits from HtmlElement. Define the component name using the propertyName parameter. Import the core element you want to inherit, such as CoreImg. Assign it a class or any other attributes as needed. Create a shadowRoot with const shadowRoot = this.attachShadow({ mode: 'open' }); Add your element to the shadowRoot using shadowRoot.appendChild(input); Define customElement. Done. Example: import { CoreInput } from '../../../core/atoms/Input/CoreInput.js'; import { CoreStyle } from '../../../core/atoms/Style/CoreStyle.js'; export class Input extends HTMLElement { static propertyName = 'app-input'; constructor(placeholder = '', name = '', type = 'text') { super(); this.placeholder = placeholder; this.name = name; this.type = type; if (this.getAttribute('placeholder')) { const placeholder = this.getAttribute('placeholder'); this.placeholder = placeholder.charAt(0).toUpperCase() + placeholder.slice(1); } if (this.getAttribute('name')) { this.name = this.getAttribute('name'); } if (this.getAttribute('type')) { this.type = this.getAttribute('type'); } const shadowRoot = this.attachShadow({ mode: 'open' }); this.createComponent(shadowRoot); } createComponent(shadowRoot) { const input = CoreInput({ placeholder: this.placeholder, name: this.name, type: this.type, class: 'input', }); const style = CoreStyle({ textContent: ` .input { color: black; padding: 0.8rem; border: 1px solid #ccc; border-radius: 5px; width: 680px; cursor: pointer; background-color: rgba(248, 249, 250, 0.8); } .input:focus { outline: none; background-color: #fff; } @media (max-width: 768px) { .input { width: 300px; } } `, }); shadowRoot.appendChild(style); shadowRoot.appendChild(input); } } customElements.define(Input.propertyName, Input);","title":"Code documentation"},{"location":"technicalGuide/installation/","text":"Requirements To run this project, you need to have Docker and Docker Compose installed. Below are instructions on how to check if these tools are installed and how to install them if they are missing. Checking Docker Installation To check if Docker is installed on your system, run the following command in your terminal: docker --version If Docker Compose is not installed, follow the instructions on the official Docker Compose website to install it. Checking Docker Compose Installation To check if Docker Compose is installed on your system, run the following command in your terminal: docker-compose --version If Docker Compose is not installed, follow the instructions on the official Docker Compose website to install it. Running the project To run the project, clone the repository and run the following commands in the project directory: clone the repository git clone git@github.com:kkedzierski/cgrd-dashboard.git cd cgrd-dashboard Run the project bash docker/run-dashboard.sh","title":"Installation"},{"location":"technicalGuide/installation/#requirements","text":"To run this project, you need to have Docker and Docker Compose installed. Below are instructions on how to check if these tools are installed and how to install them if they are missing.","title":"Requirements"},{"location":"technicalGuide/installation/#checking-docker-installation","text":"To check if Docker is installed on your system, run the following command in your terminal: docker --version If Docker Compose is not installed, follow the instructions on the official Docker Compose website to install it.","title":"Checking Docker Installation"},{"location":"technicalGuide/installation/#checking-docker-compose-installation","text":"To check if Docker Compose is installed on your system, run the following command in your terminal: docker-compose --version If Docker Compose is not installed, follow the instructions on the official Docker Compose website to install it.","title":"Checking Docker Compose Installation"},{"location":"technicalGuide/installation/#running-the-project","text":"To run the project, clone the repository and run the following commands in the project directory: clone the repository git clone git@github.com:kkedzierski/cgrd-dashboard.git cd cgrd-dashboard Run the project bash docker/run-dashboard.sh","title":"Running the project"},{"location":"technicalGuide/serverCode/","text":"Code documentation The following folders have been created in the codebase: migrations - contains migration files for database tables src/Account - contains files related to user account management src/Dashboard - contains files related to dashboard management src/Kernel - contains files related to the application kernel tests - contains unit test files How to Add a New Service to DI? In the src/Kernel/Container/ContainerServicesManager.php file, add a new service to the DI container in the registerServices method. How to Execute Migrations Up? Run make migrate-up How to Execute Migrations Down? Run make migrate-down How to Create a Test User? Run make create-test-user","title":"Server code documentation"},{"location":"technicalGuide/serverCode/#code-documentation","text":"The following folders have been created in the codebase: migrations - contains migration files for database tables src/Account - contains files related to user account management src/Dashboard - contains files related to dashboard management src/Kernel - contains files related to the application kernel tests - contains unit test files How to Add a New Service to DI? In the src/Kernel/Container/ContainerServicesManager.php file, add a new service to the DI container in the registerServices method. How to Execute Migrations Up? Run make migrate-up How to Execute Migrations Down? Run make migrate-down How to Create a Test User? Run make create-test-user","title":"Code documentation"},{"location":"technicalGuide/tests/","text":"Unit tests Unit tests are written in PHP and use (PHPUnit)[https://phpunit.de/]. To run unit tests, execute the following command in the main project directory: bash bin/unit.sh Mutation tests The tests are written in PHP and use (Infection)[https://infection.github.io/guide/]. To run mutation tests, execute the following command in the main project directory: bash bin/infection.sh All tests To run all tests, execute the following command in the main project directory: bash bin/test.sh Configuration The mutation tests are configured in the .infection.json5 file.","title":"Tests"},{"location":"technicalGuide/tests/#unit-tests","text":"Unit tests are written in PHP and use (PHPUnit)[https://phpunit.de/]. To run unit tests, execute the following command in the main project directory: bash bin/unit.sh","title":"Unit tests"},{"location":"technicalGuide/tests/#mutation-tests","text":"The tests are written in PHP and use (Infection)[https://infection.github.io/guide/]. To run mutation tests, execute the following command in the main project directory: bash bin/infection.sh","title":"Mutation tests"},{"location":"technicalGuide/tests/#all-tests","text":"To run all tests, execute the following command in the main project directory: bash bin/test.sh","title":"All tests"},{"location":"technicalGuide/tests/#configuration","text":"The mutation tests are configured in the .infection.json5 file.","title":"Configuration"},{"location":"technicalGuide/thisDocumentation/","text":"Documentation Description The documentation is written using Markdown language. The website is generated using the mkdocs tool. Directory Structure: - docs: documentation files - site: website files, generated automatically. - mkdocs.yml: configuration file for the website generating tool Building and Releasing Documentation on GitHub Pages Execute the bash command bash documentation/deploy_docs.sh After executing the command: For the main branch: the documentation will be built and released to the server. For other branches: the documentation will be built only. Building and Running Documentation Locally To build and run the documentation locally, execute the following command: bash documentation/deploy_docs.sh -l true","title":"This documentation"},{"location":"technicalGuide/thisDocumentation/#documentation-description","text":"The documentation is written using Markdown language. The website is generated using the mkdocs tool.","title":"Documentation Description"},{"location":"technicalGuide/thisDocumentation/#directory-structure","text":"- docs: documentation files - site: website files, generated automatically. - mkdocs.yml: configuration file for the website generating tool","title":"Directory Structure:"},{"location":"technicalGuide/thisDocumentation/#building-and-releasing-documentation-on-github-pages","text":"Execute the bash command bash documentation/deploy_docs.sh After executing the command: For the main branch: the documentation will be built and released to the server. For other branches: the documentation will be built only.","title":"Building and Releasing Documentation on GitHub Pages"},{"location":"technicalGuide/thisDocumentation/#building-and-running-documentation-locally","text":"To build and run the documentation locally, execute the following command: bash documentation/deploy_docs.sh -l true","title":"Building and Running Documentation Locally"}]}